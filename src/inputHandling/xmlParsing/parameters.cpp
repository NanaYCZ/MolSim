// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "parameters.hpp"

// outputParamsType
// 

const outputParamsType::baseName_type& outputParamsType::
baseName () const
{
  return this->baseName_.get ();
}

outputParamsType::baseName_type& outputParamsType::
baseName ()
{
  return this->baseName_.get ();
}

void outputParamsType::
baseName (const baseName_type& x)
{
  this->baseName_.set (x);
}

void outputParamsType::
baseName (::std::unique_ptr< baseName_type > x)
{
  this->baseName_.set (std::move (x));
}

const outputParamsType::writeFrequency_type& outputParamsType::
writeFrequency () const
{
  return this->writeFrequency_.get ();
}

outputParamsType::writeFrequency_type& outputParamsType::
writeFrequency ()
{
  return this->writeFrequency_.get ();
}

void outputParamsType::
writeFrequency (const writeFrequency_type& x)
{
  this->writeFrequency_.set (x);
}

const outputParamsType::checkpointInputFileName_optional& outputParamsType::
checkpointInputFileName () const
{
  return this->checkpointInputFileName_;
}

outputParamsType::checkpointInputFileName_optional& outputParamsType::
checkpointInputFileName ()
{
  return this->checkpointInputFileName_;
}

void outputParamsType::
checkpointInputFileName (const checkpointInputFileName_type& x)
{
  this->checkpointInputFileName_.set (x);
}

void outputParamsType::
checkpointInputFileName (const checkpointInputFileName_optional& x)
{
  this->checkpointInputFileName_ = x;
}

void outputParamsType::
checkpointInputFileName (::std::unique_ptr< checkpointInputFileName_type > x)
{
  this->checkpointInputFileName_.set (std::move (x));
}

const outputParamsType::checkpointOutputFileName_optional& outputParamsType::
checkpointOutputFileName () const
{
  return this->checkpointOutputFileName_;
}

outputParamsType::checkpointOutputFileName_optional& outputParamsType::
checkpointOutputFileName ()
{
  return this->checkpointOutputFileName_;
}

void outputParamsType::
checkpointOutputFileName (const checkpointOutputFileName_type& x)
{
  this->checkpointOutputFileName_.set (x);
}

void outputParamsType::
checkpointOutputFileName (const checkpointOutputFileName_optional& x)
{
  this->checkpointOutputFileName_ = x;
}

void outputParamsType::
checkpointOutputFileName (::std::unique_ptr< checkpointOutputFileName_type > x)
{
  this->checkpointOutputFileName_.set (std::move (x));
}


// simulationParamsType
// 

const simulationParamsType::tEnd_type& simulationParamsType::
tEnd () const
{
  return this->tEnd_.get ();
}

simulationParamsType::tEnd_type& simulationParamsType::
tEnd ()
{
  return this->tEnd_.get ();
}

void simulationParamsType::
tEnd (const tEnd_type& x)
{
  this->tEnd_.set (x);
}

const simulationParamsType::deltaT_type& simulationParamsType::
deltaT () const
{
  return this->deltaT_.get ();
}

simulationParamsType::deltaT_type& simulationParamsType::
deltaT ()
{
  return this->deltaT_.get ();
}

void simulationParamsType::
deltaT (const deltaT_type& x)
{
  this->deltaT_.set (x);
}

const simulationParamsType::cutOffRadius_type& simulationParamsType::
cutOffRadius () const
{
  return this->cutOffRadius_.get ();
}

simulationParamsType::cutOffRadius_type& simulationParamsType::
cutOffRadius ()
{
  return this->cutOffRadius_.get ();
}

void simulationParamsType::
cutOffRadius (const cutOffRadius_type& x)
{
  this->cutOffRadius_.set (x);
}

const simulationParamsType::cellSize_type& simulationParamsType::
cellSize () const
{
  return this->cellSize_.get ();
}

simulationParamsType::cellSize_type& simulationParamsType::
cellSize ()
{
  return this->cellSize_.get ();
}

void simulationParamsType::
cellSize (const cellSize_type& x)
{
  this->cellSize_.set (x);
}

const simulationParamsType::gravityFactor_optional& simulationParamsType::
gravityFactor () const
{
  return this->gravityFactor_;
}

simulationParamsType::gravityFactor_optional& simulationParamsType::
gravityFactor ()
{
  return this->gravityFactor_;
}

void simulationParamsType::
gravityFactor (const gravityFactor_type& x)
{
  this->gravityFactor_.set (x);
}

void simulationParamsType::
gravityFactor (const gravityFactor_optional& x)
{
  this->gravityFactor_ = x;
}

const simulationParamsType::forceType_type& simulationParamsType::
forceType () const
{
  return this->forceType_.get ();
}

simulationParamsType::forceType_type& simulationParamsType::
forceType ()
{
  return this->forceType_.get ();
}

void simulationParamsType::
forceType (const forceType_type& x)
{
  this->forceType_.set (x);
}

void simulationParamsType::
forceType (::std::unique_ptr< forceType_type > x)
{
  this->forceType_.set (std::move (x));
}

const simulationParamsType::parallelizationVersion_optional& simulationParamsType::
parallelizationVersion () const
{
  return this->parallelizationVersion_;
}

simulationParamsType::parallelizationVersion_optional& simulationParamsType::
parallelizationVersion ()
{
  return this->parallelizationVersion_;
}

void simulationParamsType::
parallelizationVersion (const parallelizationVersion_type& x)
{
  this->parallelizationVersion_.set (x);
}

void simulationParamsType::
parallelizationVersion (const parallelizationVersion_optional& x)
{
  this->parallelizationVersion_ = x;
}

void simulationParamsType::
parallelizationVersion (::std::unique_ptr< parallelizationVersion_type > x)
{
  this->parallelizationVersion_.set (std::move (x));
}

const simulationParamsType::Rdf_optional& simulationParamsType::
Rdf () const
{
  return this->Rdf_;
}

simulationParamsType::Rdf_optional& simulationParamsType::
Rdf ()
{
  return this->Rdf_;
}

void simulationParamsType::
Rdf (const Rdf_type& x)
{
  this->Rdf_.set (x);
}

void simulationParamsType::
Rdf (const Rdf_optional& x)
{
  this->Rdf_ = x;
}

void simulationParamsType::
Rdf (::std::unique_ptr< Rdf_type > x)
{
  this->Rdf_.set (std::move (x));
}

const simulationParamsType::diffusionStatFrequency_optional& simulationParamsType::
diffusionStatFrequency () const
{
  return this->diffusionStatFrequency_;
}

simulationParamsType::diffusionStatFrequency_optional& simulationParamsType::
diffusionStatFrequency ()
{
  return this->diffusionStatFrequency_;
}

void simulationParamsType::
diffusionStatFrequency (const diffusionStatFrequency_type& x)
{
  this->diffusionStatFrequency_.set (x);
}

void simulationParamsType::
diffusionStatFrequency (const diffusionStatFrequency_optional& x)
{
  this->diffusionStatFrequency_ = x;
}

const simulationParamsType::Thermostats_optional& simulationParamsType::
Thermostats () const
{
  return this->Thermostats_;
}

simulationParamsType::Thermostats_optional& simulationParamsType::
Thermostats ()
{
  return this->Thermostats_;
}

void simulationParamsType::
Thermostats (const Thermostats_type& x)
{
  this->Thermostats_.set (x);
}

void simulationParamsType::
Thermostats (const Thermostats_optional& x)
{
  this->Thermostats_ = x;
}

void simulationParamsType::
Thermostats (::std::unique_ptr< Thermostats_type > x)
{
  this->Thermostats_.set (std::move (x));
}

const simulationParamsType::boundaryConditions_type& simulationParamsType::
boundaryConditions () const
{
  return this->boundaryConditions_.get ();
}

simulationParamsType::boundaryConditions_type& simulationParamsType::
boundaryConditions ()
{
  return this->boundaryConditions_.get ();
}

void simulationParamsType::
boundaryConditions (const boundaryConditions_type& x)
{
  this->boundaryConditions_.set (x);
}

void simulationParamsType::
boundaryConditions (::std::unique_ptr< boundaryConditions_type > x)
{
  this->boundaryConditions_.set (std::move (x));
}

const simulationParamsType::domainDimensions_type& simulationParamsType::
domainDimensions () const
{
  return this->domainDimensions_.get ();
}

simulationParamsType::domainDimensions_type& simulationParamsType::
domainDimensions ()
{
  return this->domainDimensions_.get ();
}

void simulationParamsType::
domainDimensions (const domainDimensions_type& x)
{
  this->domainDimensions_.set (x);
}

void simulationParamsType::
domainDimensions (::std::unique_ptr< domainDimensions_type > x)
{
  this->domainDimensions_.set (std::move (x));
}


// forceTypeType
//

const forceTypeType::gravitational_optional& forceTypeType::
gravitational () const
{
  return this->gravitational_;
}

forceTypeType::gravitational_optional& forceTypeType::
gravitational ()
{
  return this->gravitational_;
}

void forceTypeType::
gravitational (const gravitational_type& x)
{
  this->gravitational_.set (x);
}

void forceTypeType::
gravitational (const gravitational_optional& x)
{
  this->gravitational_ = x;
}

void forceTypeType::
gravitational (::std::unique_ptr< gravitational_type > x)
{
  this->gravitational_.set (std::move (x));
}

const forceTypeType::Membrane_optional& forceTypeType::
Membrane () const
{
    return this->Membrane_;
}

forceTypeType::Membrane_optional& forceTypeType::
Membrane ()
{
    return this->Membrane_;
}

void forceTypeType::
Membrane (const Membrane_type& x)
{
    this->Membrane_.set (x);
}

void forceTypeType::
Membrane (const Membrane_optional& x)
{
    this->Membrane_ = x;
}

void forceTypeType::
Membrane (::std::unique_ptr< Membrane_type > x)
{
    this->Membrane_.set (std::move (x));
}

const forceTypeType::LJ_optional& forceTypeType::
LJ () const
{
  return this->LJ_;
}

forceTypeType::LJ_optional& forceTypeType::
LJ ()
{
  return this->LJ_;
}

void forceTypeType::
LJ (const LJ_type& x)
{
  this->LJ_.set (x);
}

void forceTypeType::
LJ (const LJ_optional& x)
{
  this->LJ_ = x;
}

void forceTypeType::
LJ (::std::unique_ptr< LJ_type > x)
{
  this->LJ_.set (std::move (x));
}

const forceTypeType::smoothedLJ_optional& forceTypeType::
smoothedLJ () const
{
  return this->smoothedLJ_;
}

forceTypeType::smoothedLJ_optional& forceTypeType::
smoothedLJ ()
{
  return this->smoothedLJ_;
}

void forceTypeType::
smoothedLJ (const smoothedLJ_type& x)
{
  this->smoothedLJ_.set (x);
}

void forceTypeType::
smoothedLJ (const smoothedLJ_optional& x)
{
  this->smoothedLJ_ = x;
}

void forceTypeType::
smoothedLJ (::std::unique_ptr< smoothedLJ_type > x)
{
  this->smoothedLJ_.set (std::move (x));
}


// parallelizationSettingsType
//

const parallelizationSettingsType::serial_optional& parallelizationSettingsType::
serial () const
{
  return this->serial_;
}

parallelizationSettingsType::serial_optional& parallelizationSettingsType::
serial ()
{
  return this->serial_;
}

void parallelizationSettingsType::
serial (const serial_type& x)
{
  this->serial_.set (x);
}

void parallelizationSettingsType::
serial (const serial_optional& x)
{
  this->serial_ = x;
}

void parallelizationSettingsType::
serial (::std::unique_ptr< serial_type > x)
{
  this->serial_.set (std::move (x));
}

const parallelizationSettingsType::first_method_optional& parallelizationSettingsType::
first_method () const
{
  return this->first_method_;
}

parallelizationSettingsType::first_method_optional& parallelizationSettingsType::
first_method ()
{
  return this->first_method_;
}

void parallelizationSettingsType::
first_method (const first_method_type& x)
{
  this->first_method_.set (x);
}

void parallelizationSettingsType::
first_method (const first_method_optional& x)
{
  this->first_method_ = x;
}

void parallelizationSettingsType::
first_method (::std::unique_ptr< first_method_type > x)
{
  this->first_method_.set (std::move (x));
}

const parallelizationSettingsType::second_method_optional& parallelizationSettingsType::
second_method () const
{
  return this->second_method_;
}

parallelizationSettingsType::second_method_optional& parallelizationSettingsType::
second_method ()
{
  return this->second_method_;
}

void parallelizationSettingsType::
second_method (const second_method_type& x)
{
  this->second_method_.set (x);
}

void parallelizationSettingsType::
second_method (const second_method_optional& x)
{
  this->second_method_ = x;
}

void parallelizationSettingsType::
second_method (::std::unique_ptr< second_method_type > x)
{
  this->second_method_.set (std::move (x));
}


// rdfType
//

const rdfType::rdfIntervalSize_type& rdfType::
rdfIntervalSize () const
{
  return this->rdfIntervalSize_.get ();
}

rdfType::rdfIntervalSize_type& rdfType::
rdfIntervalSize ()
{
  return this->rdfIntervalSize_.get ();
}

void rdfType::
rdfIntervalSize (const rdfIntervalSize_type& x)
{
  this->rdfIntervalSize_.set (x);
}

const rdfType::rdfStatFrequency_type& rdfType::
rdfStatFrequency () const
{
  return this->rdfStatFrequency_.get ();
}

rdfType::rdfStatFrequency_type& rdfType::
rdfStatFrequency ()
{
  return this->rdfStatFrequency_.get ();
}

void rdfType::
rdfStatFrequency (const rdfStatFrequency_type& x)
{
  this->rdfStatFrequency_.set (x);
}


// thermoStatsType
//

const thermoStatsType::initTemp_type& thermoStatsType::
initTemp () const
{
  return this->initTemp_.get ();
}

thermoStatsType::initTemp_type& thermoStatsType::
initTemp ()
{
  return this->initTemp_.get ();
}

void thermoStatsType::
initTemp (const initTemp_type& x)
{
  this->initTemp_.set (x);
}

const thermoStatsType::targetTemp_optional& thermoStatsType::
targetTemp () const
{
  return this->targetTemp_;
}

thermoStatsType::targetTemp_optional& thermoStatsType::
targetTemp ()
{
  return this->targetTemp_;
}

void thermoStatsType::
targetTemp (const targetTemp_type& x)
{
  this->targetTemp_.set (x);
}

void thermoStatsType::
targetTemp (const targetTemp_optional& x)
{
  this->targetTemp_ = x;
}

const thermoStatsType::thermoStatFrequency_type& thermoStatsType::
thermoStatFrequency () const
{
  return this->thermoStatFrequency_.get ();
}

thermoStatsType::thermoStatFrequency_type& thermoStatsType::
thermoStatFrequency ()
{
  return this->thermoStatFrequency_.get ();
}

void thermoStatsType::
thermoStatFrequency (const thermoStatFrequency_type& x)
{
  this->thermoStatFrequency_.set (x);
}

const thermoStatsType::maxTempDiff_optional& thermoStatsType::
maxTempDiff () const
{
  return this->maxTempDiff_;
}

thermoStatsType::maxTempDiff_optional& thermoStatsType::
maxTempDiff ()
{
  return this->maxTempDiff_;
}

void thermoStatsType::
maxTempDiff (const maxTempDiff_type& x)
{
  this->maxTempDiff_.set (x);
}

void thermoStatsType::
maxTempDiff (const maxTempDiff_optional& x)
{
  this->maxTempDiff_ = x;
}


// vector3DType
//

const vector3DType::x_type& vector3DType::
x () const
{
  return this->x_.get ();
}

vector3DType::x_type& vector3DType::
x ()
{
  return this->x_.get ();
}

void vector3DType::
x (const x_type& x)
{
  this->x_.set (x);
}

const vector3DType::y_type& vector3DType::
y () const
{
  return this->y_.get ();
}

vector3DType::y_type& vector3DType::
y ()
{
  return this->y_.get ();
}

void vector3DType::
y (const y_type& x)
{
  this->y_.set (x);
}

const vector3DType::z_type& vector3DType::
z () const
{
  return this->z_.get ();
}

vector3DType::z_type& vector3DType::
z ()
{
  return this->z_.get ();
}

void vector3DType::
z (const z_type& x)
{
  this->z_.set (x);
}


// boundaryConditionsType
//

const boundaryConditionsType::boundaryConditionsPositiveZ_type& boundaryConditionsType::
boundaryConditionsPositiveZ () const
{
  return this->boundaryConditionsPositiveZ_.get ();
}

boundaryConditionsType::boundaryConditionsPositiveZ_type& boundaryConditionsType::
boundaryConditionsPositiveZ ()
{
  return this->boundaryConditionsPositiveZ_.get ();
}

void boundaryConditionsType::
boundaryConditionsPositiveZ (const boundaryConditionsPositiveZ_type& x)
{
  this->boundaryConditionsPositiveZ_.set (x);
}

void boundaryConditionsType::
boundaryConditionsPositiveZ (::std::unique_ptr< boundaryConditionsPositiveZ_type > x)
{
  this->boundaryConditionsPositiveZ_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsNegativeZ_type& boundaryConditionsType::
boundaryConditionsNegativeZ () const
{
  return this->boundaryConditionsNegativeZ_.get ();
}

boundaryConditionsType::boundaryConditionsNegativeZ_type& boundaryConditionsType::
boundaryConditionsNegativeZ ()
{
  return this->boundaryConditionsNegativeZ_.get ();
}

void boundaryConditionsType::
boundaryConditionsNegativeZ (const boundaryConditionsNegativeZ_type& x)
{
  this->boundaryConditionsNegativeZ_.set (x);
}

void boundaryConditionsType::
boundaryConditionsNegativeZ (::std::unique_ptr< boundaryConditionsNegativeZ_type > x)
{
  this->boundaryConditionsNegativeZ_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsPositiveX_type& boundaryConditionsType::
boundaryConditionsPositiveX () const
{
  return this->boundaryConditionsPositiveX_.get ();
}

boundaryConditionsType::boundaryConditionsPositiveX_type& boundaryConditionsType::
boundaryConditionsPositiveX ()
{
  return this->boundaryConditionsPositiveX_.get ();
}

void boundaryConditionsType::
boundaryConditionsPositiveX (const boundaryConditionsPositiveX_type& x)
{
  this->boundaryConditionsPositiveX_.set (x);
}

void boundaryConditionsType::
boundaryConditionsPositiveX (::std::unique_ptr< boundaryConditionsPositiveX_type > x)
{
  this->boundaryConditionsPositiveX_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsNegativeX_type& boundaryConditionsType::
boundaryConditionsNegativeX () const
{
  return this->boundaryConditionsNegativeX_.get ();
}

boundaryConditionsType::boundaryConditionsNegativeX_type& boundaryConditionsType::
boundaryConditionsNegativeX ()
{
  return this->boundaryConditionsNegativeX_.get ();
}

void boundaryConditionsType::
boundaryConditionsNegativeX (const boundaryConditionsNegativeX_type& x)
{
  this->boundaryConditionsNegativeX_.set (x);
}

void boundaryConditionsType::
boundaryConditionsNegativeX (::std::unique_ptr< boundaryConditionsNegativeX_type > x)
{
  this->boundaryConditionsNegativeX_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsPositiveY_type& boundaryConditionsType::
boundaryConditionsPositiveY () const
{
  return this->boundaryConditionsPositiveY_.get ();
}

boundaryConditionsType::boundaryConditionsPositiveY_type& boundaryConditionsType::
boundaryConditionsPositiveY ()
{
  return this->boundaryConditionsPositiveY_.get ();
}

void boundaryConditionsType::
boundaryConditionsPositiveY (const boundaryConditionsPositiveY_type& x)
{
  this->boundaryConditionsPositiveY_.set (x);
}

void boundaryConditionsType::
boundaryConditionsPositiveY (::std::unique_ptr< boundaryConditionsPositiveY_type > x)
{
  this->boundaryConditionsPositiveY_.set (std::move (x));
}

const boundaryConditionsType::boundaryConditionsNegativeY_type& boundaryConditionsType::
boundaryConditionsNegativeY () const
{
  return this->boundaryConditionsNegativeY_.get ();
}

boundaryConditionsType::boundaryConditionsNegativeY_type& boundaryConditionsType::
boundaryConditionsNegativeY ()
{
  return this->boundaryConditionsNegativeY_.get ();
}

void boundaryConditionsType::
boundaryConditionsNegativeY (const boundaryConditionsNegativeY_type& x)
{
  this->boundaryConditionsNegativeY_.set (x);
}

void boundaryConditionsType::
boundaryConditionsNegativeY (::std::unique_ptr< boundaryConditionsNegativeY_type > x)
{
  this->boundaryConditionsNegativeY_.set (std::move (x));
}


// cuboidType
//

const cuboidType::position_type& cuboidType::
position () const
{
  return this->position_.get ();
}

cuboidType::position_type& cuboidType::
position ()
{
  return this->position_.get ();
}

void cuboidType::
position (const position_type& x)
{
  this->position_.set (x);
}

void cuboidType::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const cuboidType::velocity_type& cuboidType::
velocity () const
{
  return this->velocity_.get ();
}

cuboidType::velocity_type& cuboidType::
velocity ()
{
  return this->velocity_.get ();
}

void cuboidType::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboidType::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const cuboidType::dimensions_type& cuboidType::
dimensions () const
{
  return this->dimensions_.get ();
}

cuboidType::dimensions_type& cuboidType::
dimensions ()
{
  return this->dimensions_.get ();
}

void cuboidType::
dimensions (const dimensions_type& x)
{
  this->dimensions_.set (x);
}

void cuboidType::
dimensions (::std::unique_ptr< dimensions_type > x)
{
  this->dimensions_.set (std::move (x));
}

const cuboidType::meanVelocity_optional& cuboidType::
meanVelocity () const
{
  return this->meanVelocity_;
}

cuboidType::meanVelocity_optional& cuboidType::
meanVelocity ()
{
  return this->meanVelocity_;
}

void cuboidType::
meanVelocity (const meanVelocity_type& x)
{
  this->meanVelocity_.set (x);
}

void cuboidType::
meanVelocity (const meanVelocity_optional& x)
{
  this->meanVelocity_ = x;
}

const cuboidType::mass_type& cuboidType::
mass () const
{
  return this->mass_.get ();
}

cuboidType::mass_type& cuboidType::
mass ()
{
  return this->mass_.get ();
}

void cuboidType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const cuboidType::meshWidth_type& cuboidType::
meshWidth () const
{
  return this->meshWidth_.get ();
}

cuboidType::meshWidth_type& cuboidType::
meshWidth ()
{
  return this->meshWidth_.get ();
}

void cuboidType::
meshWidth (const meshWidth_type& x)
{
  this->meshWidth_.set (x);
}

const cuboidType::sigma_type& cuboidType::
sigma () const
{
  return this->sigma_.get ();
}

cuboidType::sigma_type& cuboidType::
sigma ()
{
  return this->sigma_.get ();
}

void cuboidType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const cuboidType::epsilon_type& cuboidType::
epsilon () const
{
  return this->epsilon_.get ();
}

cuboidType::epsilon_type& cuboidType::
epsilon ()
{
  return this->epsilon_.get ();
}

void cuboidType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

// membraneType
//

const membraneType::position_type& membraneType::
position () const
{
    return this->position_.get ();
}

membraneType::position_type& membraneType::
position ()
{
    return this->position_.get ();
}

void membraneType::
position (const position_type& x)
{
    this->position_.set (x);
}

void membraneType::
position (::std::unique_ptr< position_type > x)
{
    this->position_.set (std::move (x));
}

const membraneType::velocity_type& membraneType::
velocity () const
{
    return this->velocity_.get ();
}

membraneType::velocity_type& membraneType::
velocity ()
{
    return this->velocity_.get ();
}

void membraneType::
velocity (const velocity_type& x)
{
    this->velocity_.set (x);
}

void membraneType::
velocity (::std::unique_ptr< velocity_type > x)
{
    this->velocity_.set (std::move (x));
}

const membraneType::dimensions_type& membraneType::
dimensions () const
{
    return this->dimensions_.get ();
}

membraneType::dimensions_type& membraneType::
dimensions ()
{
    return this->dimensions_.get ();
}

void membraneType::
dimensions (const dimensions_type& x)
{
    this->dimensions_.set (x);
}

void membraneType::
dimensions (::std::unique_ptr< dimensions_type > x)
{
    this->dimensions_.set (std::move (x));
}



const membraneType::mass_type& membraneType::
mass () const
{
    return this->mass_.get ();
}

membraneType::mass_type& membraneType::
mass ()
{
    return this->mass_.get ();
}

void membraneType::
mass (const mass_type& x)
{
    this->mass_.set (x);
}

const membraneType::meshWidth_type& membraneType::
meshWidth () const
{
    return this->meshWidth_.get ();
}

membraneType::meshWidth_type& membraneType::
meshWidth ()
{
    return this->meshWidth_.get ();
}

void membraneType::
meshWidth (const meshWidth_type& x)
{
    this->meshWidth_.set (x);
}

const membraneType::sigma_type& membraneType::
sigma () const
{
    return this->sigma_.get ();
}

membraneType::sigma_type& membraneType::
sigma ()
{
    return this->sigma_.get ();
}

void membraneType::
sigma (const sigma_type& x)
{
    this->sigma_.set (x);
}

const membraneType::epsilon_type& membraneType::
epsilon () const
{
    return this->epsilon_.get ();
}

membraneType::epsilon_type& membraneType::
epsilon ()
{
    return this->epsilon_.get ();
}

void membraneType::
epsilon (const epsilon_type& x)
{
    this->epsilon_.set (x);
}


const membraneType::epsilon_type& membraneType::
averageBondLength () const
{
    return this->averageBondLength_.get ();
}

membraneType::epsilon_type& membraneType::
averageBondLength ()
{
    return this->averageBondLength_.get ();
}

void membraneType::
averageBondLength (const epsilon_type& x)
{
    this->averageBondLength_.set (x);
}

const membraneType::epsilon_type& membraneType::
forceParameter () const
{
    return this->forceParameter_.get ();
}

membraneType::epsilon_type& membraneType::
forceParameter ()
{
    return this->forceParameter_.get ();
}

void membraneType::
forceParameter (const epsilon_type& x)
{
    this->forceParameter_.set (x);
}


// sphereType
//

const sphereType::center_position_type& sphereType::
center_position () const
{
  return this->center_position_.get ();
}

sphereType::center_position_type& sphereType::
center_position ()
{
  return this->center_position_.get ();
}

void sphereType::
center_position (const center_position_type& x)
{
  this->center_position_.set (x);
}

void sphereType::
center_position (::std::unique_ptr< center_position_type > x)
{
  this->center_position_.set (std::move (x));
}

const sphereType::velocity_type& sphereType::
velocity () const
{
  return this->velocity_.get ();
}

sphereType::velocity_type& sphereType::
velocity ()
{
  return this->velocity_.get ();
}

void sphereType::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void sphereType::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const sphereType::meanVelocity_optional& sphereType::
meanVelocity () const
{
  return this->meanVelocity_;
}

sphereType::meanVelocity_optional& sphereType::
meanVelocity ()
{
  return this->meanVelocity_;
}

void sphereType::
meanVelocity (const meanVelocity_type& x)
{
  this->meanVelocity_.set (x);
}

void sphereType::
meanVelocity (const meanVelocity_optional& x)
{
  this->meanVelocity_ = x;
}

const sphereType::mass_type& sphereType::
mass () const
{
  return this->mass_.get ();
}

sphereType::mass_type& sphereType::
mass ()
{
  return this->mass_.get ();
}

void sphereType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const sphereType::radius_type& sphereType::
radius () const
{
  return this->radius_.get ();
}

sphereType::radius_type& sphereType::
radius ()
{
  return this->radius_.get ();
}

void sphereType::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const sphereType::meshWidth_type& sphereType::
meshWidth () const
{
  return this->meshWidth_.get ();
}

sphereType::meshWidth_type& sphereType::
meshWidth ()
{
  return this->meshWidth_.get ();
}

void sphereType::
meshWidth (const meshWidth_type& x)
{
  this->meshWidth_.set (x);
}

const sphereType::sigma_type& sphereType::
sigma () const
{
  return this->sigma_.get ();
}

sphereType::sigma_type& sphereType::
sigma ()
{
  return this->sigma_.get ();
}

void sphereType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const sphereType::epsilon_type& sphereType::
epsilon () const
{
  return this->epsilon_.get ();
}

sphereType::epsilon_type& sphereType::
epsilon ()
{
  return this->epsilon_.get ();
}

void sphereType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}


// parameters
//

const parameters::outputParameters_type& parameters::
outputParameters () const
{
  return this->outputParameters_.get ();
}

parameters::outputParameters_type& parameters::
outputParameters ()
{
  return this->outputParameters_.get ();
}

void parameters::
outputParameters (const outputParameters_type& x)
{
  this->outputParameters_.set (x);
}

void parameters::
outputParameters (::std::unique_ptr< outputParameters_type > x)
{
  this->outputParameters_.set (std::move (x));
}

const parameters::simulationParameters_type& parameters::
simulationParameters () const
{
  return this->simulationParameters_.get ();
}

parameters::simulationParameters_type& parameters::
simulationParameters ()
{
  return this->simulationParameters_.get ();
}

void parameters::
simulationParameters (const simulationParameters_type& x)
{
  this->simulationParameters_.set (x);
}

void parameters::
simulationParameters (::std::unique_ptr< simulationParameters_type > x)
{
  this->simulationParameters_.set (std::move (x));
}

const parameters::cuboids_sequence& parameters::
cuboids () const
{
  return this->cuboids_;
}

parameters::cuboids_sequence& parameters::
cuboids ()
{
  return this->cuboids_;
}

void parameters::
cuboids (const cuboids_sequence& s)
{
  this->cuboids_ = s;
}

const parameters::membranes_sequence& parameters::
membranes() const
{
    return this->membranes_;
}

parameters::membranes_sequence& parameters::
membranes ()
{
    return this->membranes_;
}

void parameters::
membranes (const membranes_sequence& s)
{
    this->membranes_ = s;
}

const parameters::spheres_sequence& parameters::
spheres () const
{
  return this->spheres_;
}

parameters::spheres_sequence& parameters::
spheres ()
{
  return this->spheres_;
}

void parameters::
spheres (const spheres_sequence& s)
{
  this->spheres_ = s;
}


// gravitational
// 


// LJ
//


// smoothedLJ
//

const smoothedLJ::r_l_type& smoothedLJ::
r_l () const
{
  return this->r_l_.get ();
}

smoothedLJ::r_l_type& smoothedLJ::
r_l ()
{
  return this->r_l_.get ();
}

void smoothedLJ::
r_l (const r_l_type& x)
{
  this->r_l_.set (x);
}


// serial
//


// first_method
//

const first_method::numThreads_optional& first_method::
numThreads () const
{
  return this->numThreads_;
}

first_method::numThreads_optional& first_method::
numThreads ()
{
  return this->numThreads_;
}

void first_method::
numThreads (const numThreads_type& x)
{
  this->numThreads_.set (x);
}

void first_method::
numThreads (const numThreads_optional& x)
{
  this->numThreads_ = x;
}


// second_method
//

const second_method::numThreads_optional& second_method::
numThreads () const
{
  return this->numThreads_;
}

second_method::numThreads_optional& second_method::
numThreads ()
{
  return this->numThreads_;
}

void second_method::
numThreads (const numThreads_type& x)
{
  this->numThreads_.set (x);
}

void second_method::
numThreads (const numThreads_optional& x)
{
  this->numThreads_ = x;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// outputParamsType
//

outputParamsType::
outputParamsType (const baseName_type& baseName,
                  const writeFrequency_type& writeFrequency)
: ::xml_schema::type (),
  baseName_ (baseName, this),
  writeFrequency_ (writeFrequency, this),
  checkpointInputFileName_ (this),
  checkpointOutputFileName_ (this)
{
}

outputParamsType::
outputParamsType (const outputParamsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  baseName_ (x.baseName_, f, this),
  writeFrequency_ (x.writeFrequency_, f, this),
  checkpointInputFileName_ (x.checkpointInputFileName_, f, this),
  checkpointOutputFileName_ (x.checkpointOutputFileName_, f, this)
{
}

outputParamsType::
outputParamsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  baseName_ (this),
  writeFrequency_ (this),
  checkpointInputFileName_ (this),
  checkpointOutputFileName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void outputParamsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // baseName
    //
    if (n.name () == "baseName" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< baseName_type > r (
        baseName_traits::create (i, f, this));

      if (!baseName_.present ())
      {
        this->baseName_.set (::std::move (r));
        continue;
      }
    }

    // writeFrequency
    //
    if (n.name () == "writeFrequency" && n.namespace_ ().empty ())
    {
      if (!writeFrequency_.present ())
      {
        this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
        continue;
      }
    }

    // checkpointInputFileName
    //
    if (n.name () == "checkpointInputFileName" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< checkpointInputFileName_type > r (
        checkpointInputFileName_traits::create (i, f, this));

      if (!this->checkpointInputFileName_)
      {
        this->checkpointInputFileName_.set (::std::move (r));
        continue;
      }
    }

    // checkpointOutputFileName
    //
    if (n.name () == "checkpointOutputFileName" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< checkpointOutputFileName_type > r (
        checkpointOutputFileName_traits::create (i, f, this));

      if (!this->checkpointOutputFileName_)
      {
        this->checkpointOutputFileName_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!baseName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseName",
      "");
  }

  if (!writeFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "writeFrequency",
      "");
  }
}

outputParamsType* outputParamsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class outputParamsType (*this, f, c);
}

outputParamsType& outputParamsType::
operator= (const outputParamsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->baseName_ = x.baseName_;
    this->writeFrequency_ = x.writeFrequency_;
    this->checkpointInputFileName_ = x.checkpointInputFileName_;
    this->checkpointOutputFileName_ = x.checkpointOutputFileName_;
  }

  return *this;
}

outputParamsType::
~outputParamsType ()
{
}

// simulationParamsType
//

simulationParamsType::
simulationParamsType (const tEnd_type& tEnd,
                      const deltaT_type& deltaT,
                      const cutOffRadius_type& cutOffRadius,
                      const cellSize_type& cellSize,
                      const forceType_type& forceType,
                      const boundaryConditions_type& boundaryConditions,
                      const domainDimensions_type& domainDimensions)
: ::xml_schema::type (),
  tEnd_ (tEnd, this),
  deltaT_ (deltaT, this),
  cutOffRadius_ (cutOffRadius, this),
  cellSize_ (cellSize, this),
  gravityFactor_ (this),
  forceType_ (forceType, this),
  parallelizationVersion_ (this),
  Rdf_ (this),
  diffusionStatFrequency_ (this),
  Thermostats_ (this),
  boundaryConditions_ (boundaryConditions, this),
  domainDimensions_ (domainDimensions, this)
{
}

simulationParamsType::
simulationParamsType (const tEnd_type& tEnd,
                      const deltaT_type& deltaT,
                      const cutOffRadius_type& cutOffRadius,
                      const cellSize_type& cellSize,
                      ::std::unique_ptr< forceType_type > forceType,
                      ::std::unique_ptr< boundaryConditions_type > boundaryConditions,
                      ::std::unique_ptr< domainDimensions_type > domainDimensions)
: ::xml_schema::type (),
  tEnd_ (tEnd, this),
  deltaT_ (deltaT, this),
  cutOffRadius_ (cutOffRadius, this),
  cellSize_ (cellSize, this),
  gravityFactor_ (this),
  forceType_ (std::move (forceType), this),
  parallelizationVersion_ (this),
  Rdf_ (this),
  diffusionStatFrequency_ (this),
  Thermostats_ (this),
  boundaryConditions_ (std::move (boundaryConditions), this),
  domainDimensions_ (std::move (domainDimensions), this)
{
}

simulationParamsType::
simulationParamsType (const simulationParamsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  tEnd_ (x.tEnd_, f, this),
  deltaT_ (x.deltaT_, f, this),
  cutOffRadius_ (x.cutOffRadius_, f, this),
  cellSize_ (x.cellSize_, f, this),
  gravityFactor_ (x.gravityFactor_, f, this),
  forceType_ (x.forceType_, f, this),
  parallelizationVersion_ (x.parallelizationVersion_, f, this),
  Rdf_ (x.Rdf_, f, this),
  diffusionStatFrequency_ (x.diffusionStatFrequency_, f, this),
  Thermostats_ (x.Thermostats_, f, this),
  boundaryConditions_ (x.boundaryConditions_, f, this),
  domainDimensions_ (x.domainDimensions_, f, this)
{
}

simulationParamsType::
simulationParamsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  tEnd_ (this),
  deltaT_ (this),
  cutOffRadius_ (this),
  cellSize_ (this),
  gravityFactor_ (this),
  forceType_ (this),
  parallelizationVersion_ (this),
  Rdf_ (this),
  diffusionStatFrequency_ (this),
  Thermostats_ (this),
  boundaryConditions_ (this),
  domainDimensions_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulationParamsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // tEnd
    //
    if (n.name () == "tEnd" && n.namespace_ ().empty ())
    {
      if (!tEnd_.present ())
      {
        this->tEnd_.set (tEnd_traits::create (i, f, this));
        continue;
      }
    }

    // deltaT
    //
    if (n.name () == "deltaT" && n.namespace_ ().empty ())
    {
      if (!deltaT_.present ())
      {
        this->deltaT_.set (deltaT_traits::create (i, f, this));
        continue;
      }
    }

    // cutOffRadius
    //
    if (n.name () == "cutOffRadius" && n.namespace_ ().empty ())
    {
      if (!cutOffRadius_.present ())
      {
        this->cutOffRadius_.set (cutOffRadius_traits::create (i, f, this));
        continue;
      }
    }

    // cellSize
    //
    if (n.name () == "cellSize" && n.namespace_ ().empty ())
    {
      if (!cellSize_.present ())
      {
        this->cellSize_.set (cellSize_traits::create (i, f, this));
        continue;
      }
    }

    // gravityFactor
    //
    if (n.name () == "gravityFactor" && n.namespace_ ().empty ())
    {
      if (!this->gravityFactor_)
      {
        this->gravityFactor_.set (gravityFactor_traits::create (i, f, this));
        continue;
      }
    }

    // forceType
    //
    if (n.name () == "forceType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< forceType_type > r (
        forceType_traits::create (i, f, this));

      if (!forceType_.present ())
      {
        this->forceType_.set (::std::move (r));
        continue;
      }
    }

    // parallelizationVersion
    //
    if (n.name () == "parallelizationVersion" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< parallelizationVersion_type > r (
        parallelizationVersion_traits::create (i, f, this));

      if (!this->parallelizationVersion_)
      {
        this->parallelizationVersion_.set (::std::move (r));
        continue;
      }
    }

    // Rdf
    //
    if (n.name () == "Rdf" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Rdf_type > r (
        Rdf_traits::create (i, f, this));

      if (!this->Rdf_)
      {
        this->Rdf_.set (::std::move (r));
        continue;
      }
    }

    // diffusionStatFrequency
    //
    if (n.name () == "diffusionStatFrequency" && n.namespace_ ().empty ())
    {
      if (!this->diffusionStatFrequency_)
      {
        this->diffusionStatFrequency_.set (diffusionStatFrequency_traits::create (i, f, this));
        continue;
      }
    }

    // Thermostats
    //
    if (n.name () == "Thermostats" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Thermostats_type > r (
        Thermostats_traits::create (i, f, this));

      if (!this->Thermostats_)
      {
        this->Thermostats_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditions
    //
    if (n.name () == "boundaryConditions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditions_type > r (
        boundaryConditions_traits::create (i, f, this));

      if (!boundaryConditions_.present ())
      {
        this->boundaryConditions_.set (::std::move (r));
        continue;
      }
    }

    // domainDimensions
    //
    if (n.name () == "domainDimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domainDimensions_type > r (
        domainDimensions_traits::create (i, f, this));

      if (!domainDimensions_.present ())
      {
        this->domainDimensions_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!tEnd_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tEnd",
      "");
  }

  if (!deltaT_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "deltaT",
      "");
  }

  if (!cutOffRadius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutOffRadius",
      "");
  }

  if (!cellSize_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cellSize",
      "");
  }

  if (!forceType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "forceType",
      "");
  }

  if (!boundaryConditions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditions",
      "");
  }

  if (!domainDimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domainDimensions",
      "");
  }
}

simulationParamsType* simulationParamsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulationParamsType (*this, f, c);
}

simulationParamsType& simulationParamsType::
operator= (const simulationParamsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->tEnd_ = x.tEnd_;
    this->deltaT_ = x.deltaT_;
    this->cutOffRadius_ = x.cutOffRadius_;
    this->cellSize_ = x.cellSize_;
    this->gravityFactor_ = x.gravityFactor_;
    this->forceType_ = x.forceType_;
    this->parallelizationVersion_ = x.parallelizationVersion_;
    this->Rdf_ = x.Rdf_;
    this->diffusionStatFrequency_ = x.diffusionStatFrequency_;
    this->Thermostats_ = x.Thermostats_;
    this->boundaryConditions_ = x.boundaryConditions_;
    this->domainDimensions_ = x.domainDimensions_;
  }

  return *this;
}

simulationParamsType::
~simulationParamsType ()
{
}

// forceTypeType
//

forceTypeType::
forceTypeType ()
: ::xml_schema::type (),
  gravitational_ (this),
  LJ_ (this),
  Membrane_ (this),
  smoothedLJ_ (this)
{
}

forceTypeType::
forceTypeType (const forceTypeType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  gravitational_ (x.gravitational_, f, this),
  LJ_ (x.LJ_, f, this),
  Membrane_ (x.Membrane_, f, this),
  smoothedLJ_ (x.smoothedLJ_, f, this)
{
}

forceTypeType::
forceTypeType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  gravitational_ (this),
  LJ_ (this),
  Membrane_ (this),
  smoothedLJ_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void forceTypeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // gravitational
    //
    if (n.name () == "gravitational" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< gravitational_type > r (
        gravitational_traits::create (i, f, this));

      if (!this->gravitational_)
      {
        this->gravitational_.set (::std::move (r));
        continue;
      }
    }

      // Membrane
      //
      if (n.name () == "Membrane" && n.namespace_ ().empty ())
      {
          ::std::unique_ptr< Membrane_type > r (
                  Membrane_traits::create (i, f, this));

          if (!this->Membrane_)
          {
              this->Membrane_.set (::std::move (r));
              continue;
          }
      }

    // LJ
    //
    if (n.name () == "LJ" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< LJ_type > r (
        LJ_traits::create (i, f, this));

      if (!this->LJ_)
      {
        this->LJ_.set (::std::move (r));
        continue;
      }
    }

    // smoothedLJ
    //
    if (n.name () == "smoothedLJ" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< smoothedLJ_type > r (
        smoothedLJ_traits::create (i, f, this));

      if (!this->smoothedLJ_)
      {
        this->smoothedLJ_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

forceTypeType* forceTypeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class forceTypeType (*this, f, c);
}

forceTypeType& forceTypeType::
operator= (const forceTypeType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->gravitational_ = x.gravitational_;
    this->LJ_ = x.LJ_;
    this->smoothedLJ_ = x.smoothedLJ_;
      this->Membrane_ = x.Membrane_;
  }

  return *this;
}

forceTypeType::
~forceTypeType ()
{
}

// parallelizationSettingsType
//

parallelizationSettingsType::
parallelizationSettingsType ()
: ::xml_schema::type (),
  serial_ (this),
  first_method_ (this),
  second_method_ (this)
{
}

parallelizationSettingsType::
parallelizationSettingsType (const parallelizationSettingsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  serial_ (x.serial_, f, this),
  first_method_ (x.first_method_, f, this),
  second_method_ (x.second_method_, f, this)
{
}

parallelizationSettingsType::
parallelizationSettingsType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  serial_ (this),
  first_method_ (this),
  second_method_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void parallelizationSettingsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // serial
    //
    if (n.name () == "serial" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< serial_type > r (
        serial_traits::create (i, f, this));

      if (!this->serial_)
      {
        this->serial_.set (::std::move (r));
        continue;
      }
    }

    // first_method
    //
    if (n.name () == "first_method" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< first_method_type > r (
        first_method_traits::create (i, f, this));

      if (!this->first_method_)
      {
        this->first_method_.set (::std::move (r));
        continue;
      }
    }

    // second_method
    //
    if (n.name () == "second_method" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< second_method_type > r (
        second_method_traits::create (i, f, this));

      if (!this->second_method_)
      {
        this->second_method_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

parallelizationSettingsType* parallelizationSettingsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parallelizationSettingsType (*this, f, c);
}

parallelizationSettingsType& parallelizationSettingsType::
operator= (const parallelizationSettingsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->serial_ = x.serial_;
    this->first_method_ = x.first_method_;
    this->second_method_ = x.second_method_;
  }

  return *this;
}

parallelizationSettingsType::
~parallelizationSettingsType ()
{
}

// rdfType
//

rdfType::
rdfType (const rdfIntervalSize_type& rdfIntervalSize,
         const rdfStatFrequency_type& rdfStatFrequency)
: ::xml_schema::type (),
  rdfIntervalSize_ (rdfIntervalSize, this),
  rdfStatFrequency_ (rdfStatFrequency, this)
{
}

rdfType::
rdfType (const rdfType& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  rdfIntervalSize_ (x.rdfIntervalSize_, f, this),
  rdfStatFrequency_ (x.rdfStatFrequency_, f, this)
{
}

rdfType::
rdfType (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  rdfIntervalSize_ (this),
  rdfStatFrequency_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void rdfType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // rdfIntervalSize
    //
    if (n.name () == "rdfIntervalSize" && n.namespace_ ().empty ())
    {
      if (!rdfIntervalSize_.present ())
      {
        this->rdfIntervalSize_.set (rdfIntervalSize_traits::create (i, f, this));
        continue;
      }
    }

    // rdfStatFrequency
    //
    if (n.name () == "rdfStatFrequency" && n.namespace_ ().empty ())
    {
      if (!rdfStatFrequency_.present ())
      {
        this->rdfStatFrequency_.set (rdfStatFrequency_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!rdfIntervalSize_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rdfIntervalSize",
      "");
  }

  if (!rdfStatFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rdfStatFrequency",
      "");
  }
}

rdfType* rdfType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class rdfType (*this, f, c);
}

rdfType& rdfType::
operator= (const rdfType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->rdfIntervalSize_ = x.rdfIntervalSize_;
    this->rdfStatFrequency_ = x.rdfStatFrequency_;
  }

  return *this;
}

rdfType::
~rdfType ()
{
}

// thermoStatsType
//

thermoStatsType::
thermoStatsType (const initTemp_type& initTemp,
                 const thermoStatFrequency_type& thermoStatFrequency)
: ::xml_schema::type (),
  initTemp_ (initTemp, this),
  targetTemp_ (this),
  thermoStatFrequency_ (thermoStatFrequency, this),
  maxTempDiff_ (this)
{
}

thermoStatsType::
thermoStatsType (const thermoStatsType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  initTemp_ (x.initTemp_, f, this),
  targetTemp_ (x.targetTemp_, f, this),
  thermoStatFrequency_ (x.thermoStatFrequency_, f, this),
  maxTempDiff_ (x.maxTempDiff_, f, this)
{
}

thermoStatsType::
thermoStatsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  initTemp_ (this),
  targetTemp_ (this),
  thermoStatFrequency_ (this),
  maxTempDiff_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void thermoStatsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // initTemp
    //
    if (n.name () == "initTemp" && n.namespace_ ().empty ())
    {
      if (!initTemp_.present ())
      {
        this->initTemp_.set (initTemp_traits::create (i, f, this));
        continue;
      }
    }

    // targetTemp
    //
    if (n.name () == "targetTemp" && n.namespace_ ().empty ())
    {
      if (!this->targetTemp_)
      {
        this->targetTemp_.set (targetTemp_traits::create (i, f, this));
        continue;
      }
    }

    // thermoStatFrequency
    //
    if (n.name () == "thermoStatFrequency" && n.namespace_ ().empty ())
    {
      if (!thermoStatFrequency_.present ())
      {
        this->thermoStatFrequency_.set (thermoStatFrequency_traits::create (i, f, this));
        continue;
      }
    }

    // maxTempDiff
    //
    if (n.name () == "maxTempDiff" && n.namespace_ ().empty ())
    {
      if (!this->maxTempDiff_)
      {
        this->maxTempDiff_.set (maxTempDiff_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!initTemp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initTemp",
      "");
  }

  if (!thermoStatFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "thermoStatFrequency",
      "");
  }
}

thermoStatsType* thermoStatsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class thermoStatsType (*this, f, c);
}

thermoStatsType& thermoStatsType::
operator= (const thermoStatsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->initTemp_ = x.initTemp_;
    this->targetTemp_ = x.targetTemp_;
    this->thermoStatFrequency_ = x.thermoStatFrequency_;
    this->maxTempDiff_ = x.maxTempDiff_;
  }

  return *this;
}

thermoStatsType::
~thermoStatsType ()
{
}

// vector3DType
//

vector3DType::
vector3DType (const x_type& x,
              const y_type& y,
              const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

vector3DType::
vector3DType (const vector3DType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

vector3DType::
vector3DType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void vector3DType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

vector3DType* vector3DType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class vector3DType (*this, f, c);
}

vector3DType& vector3DType::
operator= (const vector3DType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

vector3DType::
~vector3DType ()
{
}

// boundaryConditionsType
//

boundaryConditionsType::
boundaryConditionsType (const boundaryConditionsPositiveZ_type& boundaryConditionsPositiveZ,
                        const boundaryConditionsNegativeZ_type& boundaryConditionsNegativeZ,
                        const boundaryConditionsPositiveX_type& boundaryConditionsPositiveX,
                        const boundaryConditionsNegativeX_type& boundaryConditionsNegativeX,
                        const boundaryConditionsPositiveY_type& boundaryConditionsPositiveY,
                        const boundaryConditionsNegativeY_type& boundaryConditionsNegativeY)
: ::xml_schema::type (),
  boundaryConditionsPositiveZ_ (boundaryConditionsPositiveZ, this),
  boundaryConditionsNegativeZ_ (boundaryConditionsNegativeZ, this),
  boundaryConditionsPositiveX_ (boundaryConditionsPositiveX, this),
  boundaryConditionsNegativeX_ (boundaryConditionsNegativeX, this),
  boundaryConditionsPositiveY_ (boundaryConditionsPositiveY, this),
  boundaryConditionsNegativeY_ (boundaryConditionsNegativeY, this)
{
}

boundaryConditionsType::
boundaryConditionsType (const boundaryConditionsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  boundaryConditionsPositiveZ_ (x.boundaryConditionsPositiveZ_, f, this),
  boundaryConditionsNegativeZ_ (x.boundaryConditionsNegativeZ_, f, this),
  boundaryConditionsPositiveX_ (x.boundaryConditionsPositiveX_, f, this),
  boundaryConditionsNegativeX_ (x.boundaryConditionsNegativeX_, f, this),
  boundaryConditionsPositiveY_ (x.boundaryConditionsPositiveY_, f, this),
  boundaryConditionsNegativeY_ (x.boundaryConditionsNegativeY_, f, this)
{
}

boundaryConditionsType::
boundaryConditionsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  boundaryConditionsPositiveZ_ (this),
  boundaryConditionsNegativeZ_ (this),
  boundaryConditionsPositiveX_ (this),
  boundaryConditionsNegativeX_ (this),
  boundaryConditionsPositiveY_ (this),
  boundaryConditionsNegativeY_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundaryConditionsType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // boundaryConditionsPositiveZ
    //
    if (n.name () == "boundaryConditionsPositiveZ" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsPositiveZ_type > r (
        boundaryConditionsPositiveZ_traits::create (i, f, this));

      if (!boundaryConditionsPositiveZ_.present ())
      {
        this->boundaryConditionsPositiveZ_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsNegativeZ
    //
    if (n.name () == "boundaryConditionsNegativeZ" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsNegativeZ_type > r (
        boundaryConditionsNegativeZ_traits::create (i, f, this));

      if (!boundaryConditionsNegativeZ_.present ())
      {
        this->boundaryConditionsNegativeZ_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsPositiveX
    //
    if (n.name () == "boundaryConditionsPositiveX" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsPositiveX_type > r (
        boundaryConditionsPositiveX_traits::create (i, f, this));

      if (!boundaryConditionsPositiveX_.present ())
      {
        this->boundaryConditionsPositiveX_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsNegativeX
    //
    if (n.name () == "boundaryConditionsNegativeX" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsNegativeX_type > r (
        boundaryConditionsNegativeX_traits::create (i, f, this));

      if (!boundaryConditionsNegativeX_.present ())
      {
        this->boundaryConditionsNegativeX_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsPositiveY
    //
    if (n.name () == "boundaryConditionsPositiveY" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsPositiveY_type > r (
        boundaryConditionsPositiveY_traits::create (i, f, this));

      if (!boundaryConditionsPositiveY_.present ())
      {
        this->boundaryConditionsPositiveY_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditionsNegativeY
    //
    if (n.name () == "boundaryConditionsNegativeY" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditionsNegativeY_type > r (
        boundaryConditionsNegativeY_traits::create (i, f, this));

      if (!boundaryConditionsNegativeY_.present ())
      {
        this->boundaryConditionsNegativeY_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!boundaryConditionsPositiveZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsPositiveZ",
      "");
  }

  if (!boundaryConditionsNegativeZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsNegativeZ",
      "");
  }

  if (!boundaryConditionsPositiveX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsPositiveX",
      "");
  }

  if (!boundaryConditionsNegativeX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsNegativeX",
      "");
  }

  if (!boundaryConditionsPositiveY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsPositiveY",
      "");
  }

  if (!boundaryConditionsNegativeY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditionsNegativeY",
      "");
  }
}

boundaryConditionsType* boundaryConditionsType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaryConditionsType (*this, f, c);
}

boundaryConditionsType& boundaryConditionsType::
operator= (const boundaryConditionsType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->boundaryConditionsPositiveZ_ = x.boundaryConditionsPositiveZ_;
    this->boundaryConditionsNegativeZ_ = x.boundaryConditionsNegativeZ_;
    this->boundaryConditionsPositiveX_ = x.boundaryConditionsPositiveX_;
    this->boundaryConditionsNegativeX_ = x.boundaryConditionsNegativeX_;
    this->boundaryConditionsPositiveY_ = x.boundaryConditionsPositiveY_;
    this->boundaryConditionsNegativeY_ = x.boundaryConditionsNegativeY_;
  }

  return *this;
}

boundaryConditionsType::
~boundaryConditionsType ()
{
}

// cuboidType
//

cuboidType::
cuboidType (const position_type& position,
            const velocity_type& velocity,
            const dimensions_type& dimensions,
            const mass_type& mass,
            const meshWidth_type& meshWidth,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
: ::xml_schema::type (),
  position_ (position, this),
  velocity_ (velocity, this),
  dimensions_ (dimensions, this),
  meanVelocity_ (this),
  mass_ (mass, this),
  meshWidth_ (meshWidth, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this)
{
}

cuboidType::
cuboidType (::std::unique_ptr< position_type > position,
            ::std::unique_ptr< velocity_type > velocity,
            ::std::unique_ptr< dimensions_type > dimensions,
            const mass_type& mass,
            const meshWidth_type& meshWidth,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
: ::xml_schema::type (),
  position_ (std::move (position), this),
  velocity_ (std::move (velocity), this),
  dimensions_ (std::move (dimensions), this),
  meanVelocity_ (this),
  mass_ (mass, this),
  meshWidth_ (meshWidth, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this)
{
}

cuboidType::
cuboidType (const cuboidType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  position_ (x.position_, f, this),
  velocity_ (x.velocity_, f, this),
  dimensions_ (x.dimensions_, f, this),
  meanVelocity_ (x.meanVelocity_, f, this),
  mass_ (x.mass_, f, this),
  meshWidth_ (x.meshWidth_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this)
{
}

cuboidType::
cuboidType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  position_ (this),
  velocity_ (this),
  dimensions_ (this),
  meanVelocity_ (this),
  mass_ (this),
  meshWidth_ (this),
  sigma_ (this),
  epsilon_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboidType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // dimensions
    //
    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dimensions_type > r (
        dimensions_traits::create (i, f, this));

      if (!dimensions_.present ())
      {
        this->dimensions_.set (::std::move (r));
        continue;
      }
    }

    // meanVelocity
    //
    if (n.name () == "meanVelocity" && n.namespace_ ().empty ())
    {
      if (!this->meanVelocity_)
      {
        this->meanVelocity_.set (meanVelocity_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // meshWidth
    //
    if (n.name () == "meshWidth" && n.namespace_ ().empty ())
    {
      if (!meshWidth_.present ())
      {
        this->meshWidth_.set (meshWidth_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!sigma_.present ())
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimensions",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!meshWidth_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meshWidth",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }
}

cuboidType* cuboidType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboidType (*this, f, c);
}

cuboidType& cuboidType::
operator= (const cuboidType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->position_ = x.position_;
    this->velocity_ = x.velocity_;
    this->dimensions_ = x.dimensions_;
    this->meanVelocity_ = x.meanVelocity_;
    this->mass_ = x.mass_;
    this->meshWidth_ = x.meshWidth_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
  }

  return *this;
}

cuboidType::
~cuboidType ()
{
}

// membraneType
//

membraneType::
membraneType (const position_type& position,
            const velocity_type& velocity,
            const dimensions_type& dimensions,
            const mass_type& mass,
            const meshWidth_type& meshWidth,
            const averageBondLength_type & averageBondLength,
            const forceParameter_type & forceParameter,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
        : ::xml_schema::type (),
          position_ (position, this),
          velocity_ (velocity, this),
          dimensions_ (dimensions, this),
          mass_ (mass, this),
          meshWidth_ (meshWidth, this),
          averageBondLength_ (this),
          forceParameter_(this),
          sigma_ (sigma, this),
          epsilon_ (epsilon, this)
{
}

membraneType::
membraneType (::std::unique_ptr< position_type > position,
            ::std::unique_ptr< velocity_type > velocity,
            ::std::unique_ptr< dimensions_type > dimensions,
            const mass_type& mass,
            const meshWidth_type& meshWidth,
              const averageBondLength_type & averageBondLength,
              const forceParameter_type & forceParameter,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
        : ::xml_schema::type (),
          position_ (std::move (position), this),
          velocity_ (std::move (velocity), this),
          dimensions_ (std::move (dimensions), this),
          mass_ (mass, this),
          meshWidth_ (meshWidth, this),
          averageBondLength_ (this),
          forceParameter_(this),
          sigma_ (sigma, this),
          epsilon_ (epsilon, this)
{
}

membraneType::
membraneType (const membraneType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
        : ::xml_schema::type (x, f, c),
          position_ (x.position_, f, this),
          velocity_ (x.velocity_, f, this),
          dimensions_ (x.dimensions_, f, this),
          mass_ (x.mass_, f, this),
          meshWidth_ (x.meshWidth_, f, this),
          averageBondLength_ (x.averageBondLength_, f, this),
          forceParameter_ (x.forceParameter_, f, this),
          sigma_ (x.sigma_, f, this),
          epsilon_ (x.epsilon_, f, this)
{
}

membraneType::
membraneType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
        : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
          position_ (this),
          velocity_ (this),
          dimensions_ (this),
          mass_ (this),
          meshWidth_ (this),
          averageBondLength_ (this),
          forceParameter_(this),
          sigma_ (this),
          epsilon_ (this)
{
    if ((f & ::xml_schema::flags::base) == 0)
    {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
    }
}

void membraneType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
    for (; p.more_content (); p.next_content (false))
    {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
                ::xsd::cxx::xml::dom::name< char > (i));

        // position
        //
        if (n.name () == "position" && n.namespace_ ().empty ())
        {
            ::std::unique_ptr< position_type > r (
                    position_traits::create (i, f, this));

            if (!position_.present ())
            {
                this->position_.set (::std::move (r));
                continue;
            }
        }

        // velocity
        //
        if (n.name () == "velocity" && n.namespace_ ().empty ())
        {
            ::std::unique_ptr< velocity_type > r (
                    velocity_traits::create (i, f, this));

            if (!velocity_.present ())
            {
                this->velocity_.set (::std::move (r));
                continue;
            }
        }

        // dimensions
        //
        if (n.name () == "dimensions" && n.namespace_ ().empty ())
        {
            ::std::unique_ptr< dimensions_type > r (
                    dimensions_traits::create (i, f, this));

            if (!dimensions_.present ())
            {
                this->dimensions_.set (::std::move (r));
                continue;
            }
        }

        // meanVelocity
        //
        if (n.name () == "forceParameter" && n.namespace_ ().empty ())
        {
            if (!this->forceParameter_.present ())
            {
                this->forceParameter_.set (forceParameter_traits::create (i, f, this));
                continue;
            }
        }

        if (n.name () == "averageBondLength" && n.namespace_ ().empty ())
        {
            if (!this->averageBondLength_.present ())
            {
                this->averageBondLength_.set (forceParameter_traits::create (i, f, this));
                continue;
            }
        }

        // mass
        //
        if (n.name () == "mass" && n.namespace_ ().empty ())
        {
            if (!mass_.present ())
            {
                this->mass_.set (mass_traits::create (i, f, this));
                continue;
            }
        }

        // meshWidth
        //
        if (n.name () == "meshWidth" && n.namespace_ ().empty ())
        {
            if (!meshWidth_.present ())
            {
                this->meshWidth_.set (meshWidth_traits::create (i, f, this));
                continue;
            }
        }

        // sigma
        //
        if (n.name () == "sigma" && n.namespace_ ().empty ())
        {
            if (!sigma_.present ())
            {
                this->sigma_.set (sigma_traits::create (i, f, this));
                continue;
            }
        }

        // epsilon
        //
        if (n.name () == "epsilon" && n.namespace_ ().empty ())
        {
            if (!epsilon_.present ())
            {
                this->epsilon_.set (epsilon_traits::create (i, f, this));
                continue;
            }
        }

        break;
    }

    if (!position_.present ())
    {
        throw ::xsd::cxx::tree::expected_element< char > (
                "position",
                "");
    }

    if (!velocity_.present ())
    {
        throw ::xsd::cxx::tree::expected_element< char > (
                "velocity",
                "");
    }

    if (!dimensions_.present ())
    {
        throw ::xsd::cxx::tree::expected_element< char > (
                "dimensions",
                "");
    }

    if (!mass_.present ())
    {
        throw ::xsd::cxx::tree::expected_element< char > (
                "mass",
                "");
    }

    if (!meshWidth_.present ())
    {
        throw ::xsd::cxx::tree::expected_element< char > (
                "meshWidth",
                "");
    }

    if (!forceParameter_.present ())
    {
        throw ::xsd::cxx::tree::expected_element< char > (
                "forceParameter",
                "");
    }

    if (!averageBondLength_.present ())
    {
        throw ::xsd::cxx::tree::expected_element< char > (
                "averageBondLength",
                "");
    }

    if (!sigma_.present ())
    {
        throw ::xsd::cxx::tree::expected_element< char > (
                "sigma",
                "");
    }

    if (!epsilon_.present ())
    {
        throw ::xsd::cxx::tree::expected_element< char > (
                "epsilon",
                "");
    }
}

membraneType* membraneType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
    return new class membraneType (*this, f, c);
}

membraneType& membraneType::
operator= (const membraneType& x)
{
    if (this != &x)
    {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->position_ = x.position_;
        this->velocity_ = x.velocity_;
        this->dimensions_ = x.dimensions_;
        this->mass_ = x.mass_;
        this->meshWidth_ = x.meshWidth_;
        this->averageBondLength_ = x.averageBondLength_;
        this->forceParameter_ = x.forceParameter_;
        this->sigma_ = x.sigma_;
        this->epsilon_ = x.epsilon_;
    }

    return *this;
}

membraneType::
~membraneType ()
{
}

// sphereType
//

sphereType::
sphereType (const center_position_type& center_position,
            const velocity_type& velocity,
            const mass_type& mass,
            const radius_type& radius,
            const meshWidth_type& meshWidth,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
: ::xml_schema::type (),
  center_position_ (center_position, this),
  velocity_ (velocity, this),
  meanVelocity_ (this),
  mass_ (mass, this),
  radius_ (radius, this),
  meshWidth_ (meshWidth, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this)
{
}

sphereType::
sphereType (::std::unique_ptr< center_position_type > center_position,
            ::std::unique_ptr< velocity_type > velocity,
            const mass_type& mass,
            const radius_type& radius,
            const meshWidth_type& meshWidth,
            const sigma_type& sigma,
            const epsilon_type& epsilon)
: ::xml_schema::type (),
  center_position_ (std::move (center_position), this),
  velocity_ (std::move (velocity), this),
  meanVelocity_ (this),
  mass_ (mass, this),
  radius_ (radius, this),
  meshWidth_ (meshWidth, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this)
{
}

sphereType::
sphereType (const sphereType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  center_position_ (x.center_position_, f, this),
  velocity_ (x.velocity_, f, this),
  meanVelocity_ (x.meanVelocity_, f, this),
  mass_ (x.mass_, f, this),
  radius_ (x.radius_, f, this),
  meshWidth_ (x.meshWidth_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this)
{
}

sphereType::
sphereType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  center_position_ (this),
  velocity_ (this),
  meanVelocity_ (this),
  mass_ (this),
  radius_ (this),
  meshWidth_ (this),
  sigma_ (this),
  epsilon_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void sphereType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // center_position
    //
    if (n.name () == "center_position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< center_position_type > r (
        center_position_traits::create (i, f, this));

      if (!center_position_.present ())
      {
        this->center_position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // meanVelocity
    //
    if (n.name () == "meanVelocity" && n.namespace_ ().empty ())
    {
      if (!this->meanVelocity_)
      {
        this->meanVelocity_.set (meanVelocity_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // meshWidth
    //
    if (n.name () == "meshWidth" && n.namespace_ ().empty ())
    {
      if (!meshWidth_.present ())
      {
        this->meshWidth_.set (meshWidth_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!sigma_.present ())
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!center_position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "center_position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!meshWidth_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meshWidth",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }
}

sphereType* sphereType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphereType (*this, f, c);
}

sphereType& sphereType::
operator= (const sphereType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->center_position_ = x.center_position_;
    this->velocity_ = x.velocity_;
    this->meanVelocity_ = x.meanVelocity_;
    this->mass_ = x.mass_;
    this->radius_ = x.radius_;
    this->meshWidth_ = x.meshWidth_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
  }

  return *this;
}

sphereType::
~sphereType ()
{
}

// parameters
//

parameters::
parameters (const outputParameters_type& outputParameters,
            const simulationParameters_type& simulationParameters)
: ::xml_schema::type (),
  outputParameters_ (outputParameters, this),
  simulationParameters_ (simulationParameters, this),
  cuboids_ (this),
  spheres_ (this)
{
}

parameters::
parameters (::std::unique_ptr< outputParameters_type > outputParameters,
            ::std::unique_ptr< simulationParameters_type > simulationParameters)
: ::xml_schema::type (),
  outputParameters_ (std::move (outputParameters), this),
  simulationParameters_ (std::move (simulationParameters), this),
  cuboids_ (this),
  spheres_ (this)
{
}

parameters::
parameters (const parameters& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  outputParameters_ (x.outputParameters_, f, this),
  simulationParameters_ (x.simulationParameters_, f, this),
  cuboids_ (x.cuboids_, f, this),
  spheres_ (x.spheres_, f, this)
{
}

parameters::
parameters (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  outputParameters_ (this),
  simulationParameters_ (this),
  cuboids_ (this),
  spheres_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void parameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // outputParameters
    //
    if (n.name () == "outputParameters" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< outputParameters_type > r (
        outputParameters_traits::create (i, f, this));

      if (!outputParameters_.present ())
      {
        this->outputParameters_.set (::std::move (r));
        continue;
      }
    }

    // simulationParameters
    //
    if (n.name () == "simulationParameters" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< simulationParameters_type > r (
        simulationParameters_traits::create (i, f, this));

      if (!simulationParameters_.present ())
      {
        this->simulationParameters_.set (::std::move (r));
        continue;
      }
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      this->cuboids_.push_back (::std::move (r));
      continue;
    }

      // membranes
      //
      if (n.name () == "membranes" && n.namespace_ ().empty ())
      {
          ::std::unique_ptr< membranes_type > r (
                  membranes_traits::create (i, f, this));

          this->membranes_.push_back (::std::move (r));
          continue;
      }

    // spheres
    //
    if (n.name () == "spheres" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< spheres_type > r (
        spheres_traits::create (i, f, this));

      this->spheres_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!outputParameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outputParameters",
      "");
  }

  if (!simulationParameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "simulationParameters",
      "");
  }
}

parameters* parameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parameters (*this, f, c);
}

parameters& parameters::
operator= (const parameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->outputParameters_ = x.outputParameters_;
    this->simulationParameters_ = x.simulationParameters_;
    this->cuboids_ = x.cuboids_;
    this->membranes_ = x.membranes_;
    this->spheres_ = x.spheres_;
  }

  return *this;
}

parameters::
~parameters ()
{
}

// gravitational
//

gravitational::
gravitational ()
: ::xml_schema::type ()
{
}

gravitational::
gravitational (const gravitational& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

gravitational::
gravitational (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

gravitational::
gravitational (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

gravitational::
gravitational (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

gravitational* gravitational::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gravitational (*this, f, c);
}

gravitational::
~gravitational ()
{
}

// Membrane
//

Membrane::
Membrane ()
        : ::xml_schema::type ()
{
}

Membrane::
Membrane (const Membrane& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
        : ::xml_schema::type (x, f, c)
{
}

Membrane::
Membrane (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
        : ::xml_schema::type (e, f, c)
{
}

Membrane::
Membrane (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
        : ::xml_schema::type (a, f, c)
{
}

Membrane::
Membrane (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
        : ::xml_schema::type (s, e, f, c)
{
}

Membrane* Membrane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
    return new class Membrane (*this, f, c);
}

Membrane::
~Membrane ()
{
}

// LJ
//

LJ::
LJ ()
: ::xml_schema::type ()
{
}

LJ::
LJ (const LJ& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

LJ::
LJ (const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

LJ::
LJ (const ::xercesc::DOMAttr& a,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

LJ::
LJ (const ::std::string& s,
    const ::xercesc::DOMElement* e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

LJ* LJ::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LJ (*this, f, c);
}

LJ::
~LJ ()
{
}

// smoothedLJ
//

smoothedLJ::
smoothedLJ (const r_l_type& r_l)
: ::xml_schema::type (),
  r_l_ (r_l, this)
{
}

smoothedLJ::
smoothedLJ (const smoothedLJ& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  r_l_ (x.r_l_, f, this)
{
}

smoothedLJ::
smoothedLJ (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  r_l_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void smoothedLJ::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // r_l
    //
    if (n.name () == "r_l" && n.namespace_ ().empty ())
    {
      if (!r_l_.present ())
      {
        this->r_l_.set (r_l_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!r_l_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r_l",
      "");
  }
}

smoothedLJ* smoothedLJ::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class smoothedLJ (*this, f, c);
}

smoothedLJ& smoothedLJ::
operator= (const smoothedLJ& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->r_l_ = x.r_l_;
  }

  return *this;
}

smoothedLJ::
~smoothedLJ ()
{
}

// serial
//

serial::
serial ()
: ::xml_schema::type ()
{
}

serial::
serial (const serial& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

serial::
serial (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

serial::
serial (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

serial::
serial (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

serial* serial::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class serial (*this, f, c);
}

serial::
~serial ()
{
}

// first_method
//

first_method::
first_method ()
: ::xml_schema::type (),
  numThreads_ (this)
{
}

first_method::
first_method (const first_method& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  numThreads_ (x.numThreads_, f, this)
{
}

first_method::
first_method (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  numThreads_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void first_method::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // numThreads
    //
    if (n.name () == "numThreads" && n.namespace_ ().empty ())
    {
      if (!this->numThreads_)
      {
        this->numThreads_.set (numThreads_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

first_method* first_method::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class first_method (*this, f, c);
}

first_method& first_method::
operator= (const first_method& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->numThreads_ = x.numThreads_;
  }

  return *this;
}

first_method::
~first_method ()
{
}

// second_method
//

second_method::
second_method ()
: ::xml_schema::type (),
  numThreads_ (this)
{
}

second_method::
second_method (const second_method& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  numThreads_ (x.numThreads_, f, this)
{
}

second_method::
second_method (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  numThreads_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void second_method::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // numThreads
    //
    if (n.name () == "numThreads" && n.namespace_ ().empty ())
    {
      if (!this->numThreads_)
      {
        this->numThreads_.set (numThreads_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

second_method* second_method::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class second_method (*this, f, c);
}

second_method& second_method::
operator= (const second_method& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->numThreads_ = x.numThreads_;
  }

  return *this;
}

second_method::
~second_method ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::parameters >
parameters_ (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::parameters_ (isrc, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::parameters_ (isrc, h, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::parameters_ (isrc, h, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::parameters_ (isrc, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::parameters_ (isrc, h, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::parameters_ (isrc, h, f, p);
}

::std::unique_ptr< ::parameters >
parameters_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::parameters > (
    ::parameters_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::parameters >
parameters_ (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::parameters > (
      ::parameters_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "parameters" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::parameters > r (
      ::xsd::cxx::tree::traits< ::parameters, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "parameters",
    "");
}

::std::unique_ptr< ::parameters >
parameters_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "parameters" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::parameters > r (
      ::xsd::cxx::tree::traits< ::parameters, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "parameters",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

